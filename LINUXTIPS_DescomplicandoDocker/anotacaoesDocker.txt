### DAY 1

Containers
	remete a isolamento lógico-namespaces (processos, usuarios, rede, mountpoint) e isolamento fisico-cgroup (CPU, memoria, IO)
	
	O isolamento é entre containers, ou seja, um não enxerga os processos do outro
	
	O docker é um gerenciador de containers como:
	CHROOT foi o precursor do Docker, ele e o LXC, openVZ
		LXC - linux container
			cgroups, namespaces e chroot
		openVZ - parallels -> colocou o virtuoso open o que difundiu as VPSs

Imagem de containers
	composta de camadas
		cada instrução vai ter uma camada
	Somente na última camada é possível escrever, as camadas abaixo são ro
		Se for preciso alterar um arquivo em outra camada, vai ser criada uma cópia para que seja feita a alteração (copy on write)
	O ideal é executar as instruções necessárias juntas com o && em um unico RUN
	Vários containers podem usar a mesma imagem ro
	
	O container utiliza o Kernel do host para um melhor gerênciamento de recursos
		por exemplo um prédio com 10 apartamentos e cada apartamento com um porteiro
			isso é o que ocorre nas VMS
		módulos do kernel para comunicação dos containers
			netfilter
				iptables é o comando para interagir no netfilter
			namespaces
				pid namespaces
				net namespaces
				mnt namespaces
			cgroups
				cpu, memoria, network e disco
			netlink
			entre outros
			
	
instalando docker
	docs.docker.com/install
		ce - community edition - free
		ee - enterprise edition
		
	redhat - não roda o docker ce

	curl -fsSL https://get.docker.com | bash
		é um shellscript e o | bash vai abrir no shell para instalar
		
	Docker client
		o que vai rodar os comandos do docker na maquina - cli
	Docker server
		vai gerenciar os containers, para controle remoto
		
docker ps
	nova sintaxe - docker container ls
	
docker container ls -a
	vai mostrar os containers que já foram executados e terminados também

docker container run -ti 
	terminal e interatividade
	já vai entrar no container
		cat /etc/issue - vai mostrar a versão no container do ubuntu
		cat /etc;/redhat-release - vai mostrar a versão no container do centos
		
	ctrl d 
		sai do container como exit ou logout e mata o container - mata o entrypoint(bash no caso do ubuntu)
	ctrl pq 
		sai do container e deixa ele rodando
docker container attach IDCONTAINER
	para entrar no container em execução
	
um servidor web sempre precisa rodar em primeiro plano num container
	deve rodar com -d para ser executado com daemon
		ou seja, não pode ser executado como -ti por que o entrypoint do nginx por exemplo não é um bash
	
	docker container exec -ti COONTAINERID bash
		vai abrir o bash do container
	docker container exec CONTAINERID ls
		vai listar arquivos	
	
	
docker container stop CONTAINETID
		
docker container start CONTAINETID
		
docker container restart CONTAINETID

docker container pause CONTAINETID

docker container unpause CONTAINETID

docker container inspect CONTAINERID
	detalhes do container
		
docker container rm CONTAINERID
	rm -f
		força se em execução
docker container logs CONTAINERID
	docker container logs -f CONTAINERID

docker container stats CONTAINERID
		
docker container top CONTAINERID
	processos em execução
	
docker container run -d -m 128M nginx
	limita quantidade de memoria
		--cpus 0.5
			meio core
			
docker container update 

docker image ls
	listar as imagens baixadas

docker image build -t toskeira:1.0 .
	docker container run -d toskeira:1.0

### DAY 2

docker container prune
docker volume prune
docker image prune
	apaga todos - usar com cuidado
	
Volumes
	permite armazenar os dados em outro local fora do container
		
		tipo bind
			montar um diretório especifico dentro do container
			--mount type=bind,src-/root/giropops,dst=/giropops
		
	docker volume ls
		lista os volumes
	docker volume create giropops
		cria um volume
	docker volume inspect giropops
		
		docker container run -ti --mount type=volume,src=giropops,dst=/giropops debian
		
		docker container inspect idcontainer
		
		
	Sintaxes antigas
		docker container create -v /root/giropops/:/giropops --name dbos centos

		docker run -d -p 5432:5432 --name pgsql1 --volumes-from dbos -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSSTGRESQL_DB=docker kamui/postgresql

	criar um backup
		docker container run -ti --mount type=volume,src=dbos,dst=/data --mount type=bind,src=/root/bkp/,dst=/bkp debian tar -cvf /bkp/_bkpbanco.tar /data

	
Dockerfile criando imagens
	FROM debian

	RUN ap-get update && apt-get install -y apache2 && apt-get clean

	ENV APACHE_LOCK_DIR="/var/lock"
	ENV APACHE_PID_FILE="/var/run/apache2.pid"
	ENV APACHE_RUN_USER="www-data"
	ENV APACHE_RUN_GROUP="www-data"
	ENV APACHE_LOG_DIR="/var/log/apache2"

	LABEL description="Webserver"

	VOLUME /var/www/html/

	EXPOSE 80
	
no container run -P
	o -P vai pegar o expose do dockerfile e usar uma porta aleatória para comunicação com a do dockerfile
	
	docker image build -t meuapache:1.0 .
	
	ENTRYPOINT
		principal processo
		modo exec ou listas
			
			ENTRYPOINT ["/usr/sbin/apachectl"]
			CMD ["-D", "FOREGROUND"]

	se não quiser usar cache no build --no-cache
	
	
	difetença entre COPY e ADD
		o ADD explode arquivos tar e pega tbm aquivos da web 
	
	WORKDIR
		é onde o container vai abrir
	
multistage
	é como um pipline, trabalhando uma parte primeiro e copiando o resultado para outro from
	
FROM golang AS buildando

WORKDIR /app

ADD . /app

ENV GO111MODULE=off

RUN go build -o meugo

FROM alpine

WORKDIR /giropops

COPY --from=buildando /app/meugo /giropops


ENTRYPOINT ./meugo


DOCKERHUB
	docker login
	
docker container rm -f $(docker ps -q)
	para remover todos containers em execução

docker image tag IMAGEID DOCKERUSE/IMAGENAME:VESION

docker push meu_apache:1.0.4


REGISTRY
	armazenamento local ou fora do dockerhub
	
	docker run -d -p 5000:5000 --restart=always --name registryLocal registry:2
	
	docker logout
	
	docker image tag IMAGEID localhost:5000/meuapache2:1.0.3
	
	curl localhost:5000/v2/_catalog
		para ver o que tem de imagem no registry
	
### DAY 3	

	
	
	
	
	
	
LinuxTips-DescomplicandoDocker - 
		
