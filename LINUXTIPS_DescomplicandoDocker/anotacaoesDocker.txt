### DAY 1

Containers
	remete a isolamento lógico-namespaces (processos, usuarios, rede, mountpoint) e isolamento fisico-cgroup (CPU, memoria, IO)
	
	O isolamento é entre containers, ou seja, um não enxerga os processos do outro
	
	O docker é um gerenciador de containers como:
	CHROOT foi o precursor do Docker, ele e o LXC, openVZ
		LXC - linux container
			cgroups, namespaces e chroot
		openVZ - parallels -> colocou o virtuoso open o que difundiu as VPSs

Imagem de containers
	composta de camadas
		cada instrução vai ter uma camada
	Somente na última camada é possível escrever, as camadas abaixo são ro
		Se for preciso alterar um arquivo em outra camada, vai ser criada uma cópia para que seja feita a alteração (copy on write)
	O ideal é executar as instruções necessárias juntas com o && em um unico RUN
	Vários containers podem usar a mesma imagem ro
	
	O container utiliza o Kernel do host para um melhor gerênciamento de recursos
		por exemplo um prédio com 10 apartamentos e cada apartamento com um porteiro
			isso é o que ocorre nas VMS
		módulos do kernel para comunicação dos containers
			netfilter
				iptables é o comando para interagir no netfilter
			namespaces
				pid namespaces
				net namespaces
				mnt namespaces
			cgroups
				cpu, memoria, network e disco
			netlink
			entre outros
			
	
instalando docker
	docs.docker.com/install
		ce - community edition - free
		ee - enterprise edition
		
	redhat - não roda o docker ce

	curl -fsSL https://get.docker.com | bash
		é um shellscript e o | bash vai abrir no shell para instalar
		
	Docker client
		o que vai rodar os comandos do docker na maquina - cli
	Docker server
		vai gerenciar os containers, para controle remoto
		
docker ps
	nova sintaxe - docker container ls
	
docker container ls -a
	vai mostrar os containers que já foram executados e terminados também

docker container run -ti 
	terminal e interatividade
	já vai entrar no container
		cat /etc/issue - vai mostrar a versão no container do ubuntu
		cat /etc;/redhat-release - vai mostrar a versão no container do centos
		
	ctrl d 
		sai do container como exit ou logout e mata o container - mata o entrypoint(bash no caso do ubuntu)
	ctrl pq 
		sai do container e deixa ele rodando
docker container attach IDCONTAINER
	para entrar no container em execução
	
um servidor web sempre precisa rodar em primeiro plano num container
	deve rodar com -d para ser executado com daemon
		ou seja, não pode ser executado como -ti por que o entrypoint do nginx por exemplo não é um bash
	
	docker container exec -ti COONTAINERID bash
		vai abrir o bash do container
	docker container exec CONTAINERID ls
		vai listar arquivos	
	
	
docker container stop CONTAINETID
		
docker container start CONTAINETID
		
docker container restart CONTAINETID

docker container pause CONTAINETID

docker container unpause CONTAINETID

docker container inspect CONTAINERID
	detalhes do container
		
docker container rm CONTAINERID
	rm -f
		força se em execução
docker container logs CONTAINERID
	docker container logs -f CONTAINERID

docker container stats CONTAINERID
		
docker container top CONTAINERID
	processos em execução
	
docker container run -d -m 128M nginx
	limita quantidade de memoria
		--cpus 0.5
			meio core
			
docker container update 

docker image ls
	listar as imagens baixadas

docker image build -t toskeira:1.0 .
	docker container run -d toskeira:1.0

### DAY 2

docker container prune
docker volume prune
docker image prune
	apaga todos - usar com cuidado
	
Volumes
	permite armazenar os dados em outro local fora do container
		
		tipo bind
			montar um diretório especifico dentro do container
			--mount type=bind,src-/root/giropops,dst=/giropops
		
	docker volume ls
		lista os volumes
	docker volume create giropops
		cria um volume
	docker volume inspect giropops
		
		docker container run -ti --mount type=volume,src=giropops,dst=/giropops debian
		
		docker container inspect idcontainer
		
		
	Sintaxes antigas
		docker container create -v /root/giropops/:/giropops --name dbos centos

		docker run -d -p 5432:5432 --name pgsql1 --volumes-from dbos -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSSTGRESQL_DB=docker kamui/postgresql

	criar um backup
		docker container run -ti --mount type=volume,src=dbos,dst=/data --mount type=bind,src=/root/bkp/,dst=/bkp debian tar -cvf /bkp/_bkpbanco.tar /data

	
Dockerfile criando imagens
	FROM debian

	RUN ap-get update && apt-get install -y apache2 && apt-get clean

	ENV APACHE_LOCK_DIR="/var/lock"
	ENV APACHE_PID_FILE="/var/run/apache2.pid"
	ENV APACHE_RUN_USER="www-data"
	ENV APACHE_RUN_GROUP="www-data"
	ENV APACHE_LOG_DIR="/var/log/apache2"

	LABEL description="Webserver"

	VOLUME /var/www/html/

	EXPOSE 80
	
no container run -P
	o -P vai pegar o expose do dockerfile e usar uma porta aleatória para comunicação com a do dockerfile
	
	docker image build -t meuapache:1.0 .
	
	ENTRYPOINT
		principal processo
		modo exec ou listas
			
			ENTRYPOINT ["/usr/sbin/apachectl"]
			CMD ["-D", "FOREGROUND"]

	se não quiser usar cache no build --no-cache
	
	
	difetença entre COPY e ADD
		o ADD explode arquivos tar e pega tbm aquivos da web 
	
	WORKDIR
		é onde o container vai abrir
	
multistage
	é como um pipline, trabalhando uma parte primeiro e copiando o resultado para outro from
	
FROM golang AS buildando

WORKDIR /app

ADD . /app

ENV GO111MODULE=off

RUN go build -o meugo

FROM alpine

WORKDIR /giropops

COPY --from=buildando /app/meugo /giropops


ENTRYPOINT ./meugo


DOCKERHUB
	docker login
	
docker container rm -f $(docker ps -q)
	para remover todos containers em execução

docker image tag IMAGEID DOCKERUSE/IMAGENAME:VESION

docker push meu_apache:1.0.4


REGISTRY
	armazenamento local ou fora do dockerhub
	
	docker run -d -p 5000:5000 --restart=always --name registryLocal registry:2
	
	docker logout
	
	docker image tag IMAGEID localhost:5000/meuapache2:1.0.3
	
	curl localhost:5000/v2/_catalog
		para ver o que tem de imagem no registry
	
### DAY 3	

DOCKERMACHINE
	precisa ser instalado no desktop para gerenciar as vms rodando docker
	
docker swarm init
	no node manager
docker swarm join --token SWMTKN-1-2lytmxq0c2pn7hp8yutf5amv6d96zecd7zwa083djfr3pnjnqx-3o9clsp7qvi2cqvu5v6l9alnp 192.168.1.8:2377
	nos nodes criados
	
docker node promote node2
	o node foi promovido para manager como Reachable
docker node demote node2 
	remove a promoção
docker swarm leave
	para o node sair do clister, caso ele seja manager precisa do -f
docker node rm -f node1
	para remover o node do cluster

lembrar que com mais interfaces de rede precisa especificar em qual sera o ip
	docker swarm init --advertise-addr 192.168.0.1
	
docker swarm join-token worker
			manager
	para pegar o token novamente para adicionar no cluster
	
docker swarm join-token --rotate manager
	altera o token do manager, é importante para segurança
	
docker node inspect node1
	traz informações do node
	
node update --availability pause node1
	pausa a disponibilidade do node
	
docker service create --name webserver --replicas 3 -p 8080:80 nginx
	cria um serviço com 3 replicas
docker service ps webserver
	para saber onde está rodando
	
docker service scale webserver=10
	aumenta a quantidade de containers
	
docker node --availability drain node2
	remove o node do serviço
	quando reativar o node após uma manutenção por exemplo vai ser preciso dar um scale down depois um scale
		docker service scale webserver=3
docker service rm webserver
	remove o serviço
	
Services
	pode ser uma forma de ter resiliência nos containers e escalabilidade
	forma de ter diversos containers respondendo ao mesmo serviço, são as replicas ou tasks
	cria todas as replicas e disribui no cluster
	faz um balanceamento de carga no estino round robbin 
	
	docker service ls
		id e nome
		mode
			replicado
			global
		replicas
			3/3
				pediu 3 e 3 estão disponíveis
		imagens e portas
	docker service inspect giropops --pretty
		pretty mostra a saida mais bonitinha
		
	docker service scale giropops=10
		scale up
	docker service scale giropops=3
		scale down
	docker service logs -f giropops
		logs de todos os nodes
		
	docker service create --name giropops --replicas 3 -p 8080:80 --mount type=,src=giropops,dst=/usr/share/nginx/html/ nginx
		o primeiro index foi alterado mas nos nodes não, por default o docker não faz o sync do conteúdo entre os volumes
		para isso funcionar precisaria ter outro recurso como um plugin (flocker, cloud storm ..)
			se usava antigamente o nfs-server e nfs-common -> nos nodes - apenas para linux mas não é o indicado. Para o linux pode usar o cluster fs, e em cloud tem opções de cada player 
		--hostname
			vai definir o nome do container
		--limit-cpu 0.25 --limit-memory 64M
		
### DAY4

Secrets só funcionam em swarm

Secrets por linha de comando
	echo -n "GIROPOPS STRIGUS GIRUS" | docker secret create jeferson -
		
	docker secret ls
	
	docker secret inspect jeferson
Secrets por aquivo
	echo -n "GIROPOPS STRIGUS GIRUS" > teste.txt
	
	docker secret create jeferson-arquivo teste.txt
	
docker service create --name giropops -p 8080:80 --secret jeferson-arquivo nginx

	o secret fica em /run/secrets dentro do container
	
	docker service update --secret-add jeferson giropops
		para adiconar
	docker service update --secret-rm jeferson giropops
		para remover
			vai atualizar as 3 instâncias
			
Compose
	a partir da versão 3 passou a ter possibilidade de usar com service
	
	root@ubtserver:~/composes/primeiro# cat docker-compose.yml 
	version: "3.7"
	services:
	  web:
	    image: nginx
	    deploy:
	      replicas: 5
	      resources:
		limits:
		  cpus: "0.1"
		  memory: 50M
	      restart_policy:
		condition: on-failure
	    ports:
	    - "8080:80"
	    networks:
	    - webserver
	networks:
	  webserver:
	root@ubtserver:~/composes/primeiro# 

	docker stack deploy -c docker-compose.yml giropops
		-c é por que vai ser um compose file
		
	docker stack ls
	
	docker stack ps giropops
	
	docker stack services giropops
	
dockerfile é para criar a imagem e o docker compose é para imagem pronta para deploy
	
	
	placement no docker-compose
		escolher onde a imagem vair ser colocado
	
	docker node update --label-add dc=UK ubtserver
		para atualizar a label do node
		
	O visualizer é uma forma gráfica para exibir os containers no navegador	
	
		
		
		
		
	
LinuxTips-DescomplicandoDocker - Revisar docker swarm parte e docker swarm service e network
		
